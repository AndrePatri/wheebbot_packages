/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.7.0 Sun Feb  6 13:23:56 2022.
 */

#include <string.h>

#include "odrive_cansimple.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int odrive_cansimple_heartbeat_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_heartbeat_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_error, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->axis_state, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->motor_flags, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->encoder_flags, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->controller_flags, 0u, 0xffu);

    return (8);
}

int odrive_cansimple_heartbeat_unpack(
    struct odrive_cansimple_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->axis_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->axis_state = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->motor_flags = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->encoder_flags = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->controller_flags = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_heartbeat_axis_error_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_heartbeat_axis_error_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_heartbeat_axis_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint8_t odrive_cansimple_heartbeat_axis_state_encode(double value)
{
    return (uint8_t)(value);
}

double odrive_cansimple_heartbeat_axis_state_decode(uint8_t value)
{
    return ((double)value);
}

bool odrive_cansimple_heartbeat_axis_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t odrive_cansimple_heartbeat_motor_flags_encode(double value)
{
    return (uint8_t)(value);
}

double odrive_cansimple_heartbeat_motor_flags_decode(uint8_t value)
{
    return ((double)value);
}

bool odrive_cansimple_heartbeat_motor_flags_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t odrive_cansimple_heartbeat_encoder_flags_encode(double value)
{
    return (uint8_t)(value);
}

double odrive_cansimple_heartbeat_encoder_flags_decode(uint8_t value)
{
    return ((double)value);
}

bool odrive_cansimple_heartbeat_encoder_flags_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t odrive_cansimple_heartbeat_controller_flags_encode(double value)
{
    return (uint8_t)(value);
}

double odrive_cansimple_heartbeat_controller_flags_decode(uint8_t value)
{
    return ((double)value);
}

bool odrive_cansimple_heartbeat_controller_flags_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_estop_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_estop_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_estop_unpack(
    struct odrive_cansimple_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_get_motor_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_motor_error_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->motor_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->motor_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->motor_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->motor_error, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_motor_error_unpack(
    struct odrive_cansimple_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->motor_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->motor_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_get_motor_error_motor_error_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_get_motor_error_motor_error_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_get_motor_error_motor_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_error_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->encoder_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->encoder_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->encoder_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->encoder_error, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_encoder_error_unpack(
    struct odrive_cansimple_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->encoder_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->encoder_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_get_encoder_error_encoder_error_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_get_encoder_error_encoder_error_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_get_encoder_error_encoder_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_sensorless_error_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->sensorless_error, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->sensorless_error, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->sensorless_error, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->sensorless_error, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_sensorless_error_unpack(
    struct odrive_cansimple_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->sensorless_error = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->sensorless_error |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->sensorless_error |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->sensorless_error |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_get_sensorless_error_sensorless_error_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_get_sensorless_error_sensorless_error_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_get_sensorless_error_sensorless_error_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_axis_node_id_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_node_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_node_id, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_node_id, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_node_id, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_axis_node_id_unpack(
    struct odrive_cansimple_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->axis_node_id = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_node_id |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_node_id |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_node_id |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_set_axis_node_id_axis_node_id_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_set_axis_node_id_axis_node_id_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_set_axis_node_id_axis_node_id_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_axis_state_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_axis_state_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->axis_requested_state, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->axis_requested_state, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->axis_requested_state, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->axis_requested_state, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_axis_state_unpack(
    struct odrive_cansimple_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->axis_requested_state = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->axis_requested_state |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_set_axis_state_axis_requested_state_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_set_axis_state_axis_requested_state_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_set_axis_state_axis_requested_state_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_estimates_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&pos_estimate, &src_p->pos_estimate, sizeof(pos_estimate));
    dst_p[0] |= pack_left_shift_u32(pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pos_estimate, 24u, 0xffu);
    memcpy(&vel_estimate, &src_p->vel_estimate, sizeof(vel_estimate));
    dst_p[4] |= pack_left_shift_u32(vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vel_estimate, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_encoder_estimates_unpack(
    struct odrive_cansimple_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_estimate;
    uint32_t vel_estimate;

    if (size < 8u) {
        return (-EINVAL);
    }

    pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pos_estimate, &pos_estimate, sizeof(dst_p->pos_estimate));
    vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vel_estimate, &vel_estimate, sizeof(dst_p->vel_estimate));

    return (0);
}

float odrive_cansimple_get_encoder_estimates_pos_estimate_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_encoder_estimates_pos_estimate_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_encoder_estimates_pos_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_get_encoder_estimates_vel_estimate_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_encoder_estimates_vel_estimate_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_encoder_estimates_vel_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_count_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->shadow_count, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->shadow_count, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->shadow_count, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->shadow_count, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->count_in_cpr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->count_in_cpr, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->count_in_cpr, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->count_in_cpr, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_encoder_count_unpack(
    struct odrive_cansimple_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->shadow_count = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->shadow_count |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->count_in_cpr = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->count_in_cpr |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_get_encoder_count_shadow_count_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_get_encoder_count_shadow_count_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_get_encoder_count_shadow_count_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t odrive_cansimple_get_encoder_count_count_in_cpr_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_get_encoder_count_count_in_cpr_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_get_encoder_count_count_in_cpr_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_controller_mode_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->control_mode, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->control_mode, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->control_mode, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->control_mode, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->input_mode, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->input_mode, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->input_mode, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->input_mode, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_controller_mode_unpack(
    struct odrive_cansimple_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->control_mode = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->control_mode |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->input_mode = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->input_mode |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t odrive_cansimple_set_controller_mode_control_mode_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_set_controller_mode_control_mode_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_set_controller_mode_control_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t odrive_cansimple_set_controller_mode_input_mode_encode(double value)
{
    return (uint32_t)(value);
}

double odrive_cansimple_set_controller_mode_input_mode_decode(uint32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_set_controller_mode_input_mode_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_input_pos_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_pos_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_pos, &src_p->input_pos, sizeof(input_pos));
    dst_p[0] |= pack_left_shift_u32(input_pos, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_pos, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_pos, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_pos, 24u, 0xffu);
    vel_ff = (uint16_t)src_p->vel_ff;
    dst_p[4] |= pack_left_shift_u16(vel_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(vel_ff, 8u, 0xffu);
    torque_ff = (uint16_t)src_p->torque_ff;
    dst_p[6] |= pack_left_shift_u16(torque_ff, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(torque_ff, 8u, 0xffu);

    return (8);
}

int odrive_cansimple_set_input_pos_unpack(
    struct odrive_cansimple_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t torque_ff;
    uint16_t vel_ff;
    uint32_t input_pos;

    if (size < 8u) {
        return (-EINVAL);
    }

    input_pos = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_pos |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_pos, &input_pos, sizeof(dst_p->input_pos));
    vel_ff = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    vel_ff |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->vel_ff = (int16_t)vel_ff;
    torque_ff = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    torque_ff |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->torque_ff = (int16_t)torque_ff;

    return (0);
}

float odrive_cansimple_set_input_pos_input_pos_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_input_pos_input_pos_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_input_pos_input_pos_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t odrive_cansimple_set_input_pos_vel_ff_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double odrive_cansimple_set_input_pos_vel_ff_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool odrive_cansimple_set_input_pos_vel_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t odrive_cansimple_set_input_pos_torque_ff_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double odrive_cansimple_set_input_pos_torque_ff_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool odrive_cansimple_set_input_pos_torque_ff_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_input_vel_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_vel_t *src_p,
    size_t size)
{
    uint32_t input_torque_ff;
    uint32_t input_vel;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_vel, &src_p->input_vel, sizeof(input_vel));
    dst_p[0] |= pack_left_shift_u32(input_vel, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_vel, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_vel, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_vel, 24u, 0xffu);
    memcpy(&input_torque_ff, &src_p->input_torque_ff, sizeof(input_torque_ff));
    dst_p[4] |= pack_left_shift_u32(input_torque_ff, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(input_torque_ff, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(input_torque_ff, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(input_torque_ff, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_input_vel_unpack(
    struct odrive_cansimple_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t input_torque_ff;
    uint32_t input_vel;

    if (size < 8u) {
        return (-EINVAL);
    }

    input_vel = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_vel |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_vel, &input_vel, sizeof(dst_p->input_vel));
    input_torque_ff = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    input_torque_ff |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    input_torque_ff |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    input_torque_ff |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->input_torque_ff, &input_torque_ff, sizeof(dst_p->input_torque_ff));

    return (0);
}

float odrive_cansimple_set_input_vel_input_vel_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_input_vel_input_vel_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_input_vel_input_vel_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_set_input_vel_input_torque_ff_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_input_vel_input_torque_ff_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_input_vel_input_torque_ff_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_input_torque_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_torque_t *src_p,
    size_t size)
{
    uint32_t input_torque;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&input_torque, &src_p->input_torque, sizeof(input_torque));
    dst_p[0] |= pack_left_shift_u32(input_torque, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(input_torque, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(input_torque, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(input_torque, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_input_torque_unpack(
    struct odrive_cansimple_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t input_torque;

    if (size < 8u) {
        return (-EINVAL);
    }

    input_torque = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    input_torque |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    input_torque |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    input_torque |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->input_torque, &input_torque, sizeof(dst_p->input_torque));

    return (0);
}

float odrive_cansimple_set_input_torque_input_torque_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_input_torque_input_torque_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_input_torque_input_torque_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_limits_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_limits_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&velocity_limit, &src_p->velocity_limit, sizeof(velocity_limit));
    dst_p[0] |= pack_left_shift_u32(velocity_limit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(velocity_limit, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(velocity_limit, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(velocity_limit, 24u, 0xffu);
    memcpy(&current_limit, &src_p->current_limit, sizeof(current_limit));
    dst_p[4] |= pack_left_shift_u32(current_limit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(current_limit, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(current_limit, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(current_limit, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_limits_unpack(
    struct odrive_cansimple_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t current_limit;
    uint32_t velocity_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    velocity_limit = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    velocity_limit |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->velocity_limit, &velocity_limit, sizeof(dst_p->velocity_limit));
    current_limit = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    current_limit |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->current_limit, &current_limit, sizeof(dst_p->current_limit));

    return (0);
}

float odrive_cansimple_set_limits_velocity_limit_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_limits_velocity_limit_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_limits_velocity_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_set_limits_current_limit_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_limits_current_limit_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_limits_current_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_start_anticogging_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_start_anticogging_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_start_anticogging_unpack(
    struct odrive_cansimple_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_vel_limit_t *src_p,
    size_t size)
{
    uint32_t traj_vel_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&traj_vel_limit, &src_p->traj_vel_limit, sizeof(traj_vel_limit));
    dst_p[0] |= pack_left_shift_u32(traj_vel_limit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(traj_vel_limit, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(traj_vel_limit, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(traj_vel_limit, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_traj_vel_limit_unpack(
    struct odrive_cansimple_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t traj_vel_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    traj_vel_limit = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    traj_vel_limit |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    traj_vel_limit |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    traj_vel_limit |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->traj_vel_limit, &traj_vel_limit, sizeof(dst_p->traj_vel_limit));

    return (0);
}

float odrive_cansimple_set_traj_vel_limit_traj_vel_limit_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_traj_vel_limit_traj_vel_limit_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_traj_vel_limit_traj_vel_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_accel_limits_t *src_p,
    size_t size)
{
    uint32_t traj_accel_limit;
    uint32_t traj_decel_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&traj_accel_limit, &src_p->traj_accel_limit, sizeof(traj_accel_limit));
    dst_p[0] |= pack_left_shift_u32(traj_accel_limit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(traj_accel_limit, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(traj_accel_limit, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(traj_accel_limit, 24u, 0xffu);
    memcpy(&traj_decel_limit, &src_p->traj_decel_limit, sizeof(traj_decel_limit));
    dst_p[4] |= pack_left_shift_u32(traj_decel_limit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(traj_decel_limit, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(traj_decel_limit, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(traj_decel_limit, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_traj_accel_limits_unpack(
    struct odrive_cansimple_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t traj_accel_limit;
    uint32_t traj_decel_limit;

    if (size < 8u) {
        return (-EINVAL);
    }

    traj_accel_limit = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    traj_accel_limit |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    traj_accel_limit |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    traj_accel_limit |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->traj_accel_limit, &traj_accel_limit, sizeof(dst_p->traj_accel_limit));
    traj_decel_limit = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    traj_decel_limit |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    traj_decel_limit |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    traj_decel_limit |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->traj_decel_limit, &traj_decel_limit, sizeof(dst_p->traj_decel_limit));

    return (0);
}

float odrive_cansimple_set_traj_accel_limits_traj_accel_limit_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_traj_accel_limits_traj_accel_limit_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_traj_accel_limits_traj_accel_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_set_traj_accel_limits_traj_decel_limit_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_traj_accel_limits_traj_decel_limit_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_traj_accel_limits_traj_decel_limit_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_inertia_t *src_p,
    size_t size)
{
    uint32_t traj_inertia;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&traj_inertia, &src_p->traj_inertia, sizeof(traj_inertia));
    dst_p[0] |= pack_left_shift_u32(traj_inertia, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(traj_inertia, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(traj_inertia, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(traj_inertia, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_traj_inertia_unpack(
    struct odrive_cansimple_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t traj_inertia;

    if (size < 8u) {
        return (-EINVAL);
    }

    traj_inertia = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    traj_inertia |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    traj_inertia |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    traj_inertia |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->traj_inertia, &traj_inertia, sizeof(dst_p->traj_inertia));

    return (0);
}

float odrive_cansimple_set_traj_inertia_traj_inertia_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_traj_inertia_traj_inertia_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_traj_inertia_traj_inertia_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_iq_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_iq_t *src_p,
    size_t size)
{
    uint32_t iq_measured;
    uint32_t iq_setpoint;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&iq_setpoint, &src_p->iq_setpoint, sizeof(iq_setpoint));
    dst_p[0] |= pack_left_shift_u32(iq_setpoint, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(iq_setpoint, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(iq_setpoint, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(iq_setpoint, 24u, 0xffu);
    memcpy(&iq_measured, &src_p->iq_measured, sizeof(iq_measured));
    dst_p[4] |= pack_left_shift_u32(iq_measured, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(iq_measured, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(iq_measured, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(iq_measured, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_iq_unpack(
    struct odrive_cansimple_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t iq_measured;
    uint32_t iq_setpoint;

    if (size < 8u) {
        return (-EINVAL);
    }

    iq_setpoint = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    iq_setpoint |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    iq_setpoint |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    iq_setpoint |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->iq_setpoint, &iq_setpoint, sizeof(dst_p->iq_setpoint));
    iq_measured = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    iq_measured |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    iq_measured |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    iq_measured |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->iq_measured, &iq_measured, sizeof(dst_p->iq_measured));

    return (0);
}

float odrive_cansimple_get_iq_iq_setpoint_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_iq_iq_setpoint_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_iq_iq_setpoint_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_get_iq_iq_measured_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_iq_iq_measured_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_iq_iq_measured_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_sensorless_estimates_t *src_p,
    size_t size)
{
    uint32_t sensorless_pos_estimate;
    uint32_t sensorless_vel_estimate;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&sensorless_pos_estimate, &src_p->sensorless_pos_estimate, sizeof(sensorless_pos_estimate));
    dst_p[0] |= pack_left_shift_u32(sensorless_pos_estimate, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(sensorless_pos_estimate, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(sensorless_pos_estimate, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(sensorless_pos_estimate, 24u, 0xffu);
    memcpy(&sensorless_vel_estimate, &src_p->sensorless_vel_estimate, sizeof(sensorless_vel_estimate));
    dst_p[4] |= pack_left_shift_u32(sensorless_vel_estimate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(sensorless_vel_estimate, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(sensorless_vel_estimate, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(sensorless_vel_estimate, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_sensorless_estimates_unpack(
    struct odrive_cansimple_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t sensorless_pos_estimate;
    uint32_t sensorless_vel_estimate;

    if (size < 8u) {
        return (-EINVAL);
    }

    sensorless_pos_estimate = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    sensorless_pos_estimate |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    sensorless_pos_estimate |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    sensorless_pos_estimate |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->sensorless_pos_estimate, &sensorless_pos_estimate, sizeof(dst_p->sensorless_pos_estimate));
    sensorless_vel_estimate = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    sensorless_vel_estimate |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    sensorless_vel_estimate |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    sensorless_vel_estimate |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->sensorless_vel_estimate, &sensorless_vel_estimate, sizeof(dst_p->sensorless_vel_estimate));

    return (0);
}

float odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_reboot_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_reboot_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_reboot_unpack(
    struct odrive_cansimple_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_vbus_voltage_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&vbus_voltage, &src_p->vbus_voltage, sizeof(vbus_voltage));
    dst_p[0] |= pack_left_shift_u32(vbus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vbus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vbus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vbus_voltage, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_get_vbus_voltage_unpack(
    struct odrive_cansimple_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vbus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    vbus_voltage = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vbus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vbus_voltage, &vbus_voltage, sizeof(dst_p->vbus_voltage));

    return (0);
}

float odrive_cansimple_get_vbus_voltage_vbus_voltage_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_get_vbus_voltage_vbus_voltage_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_get_vbus_voltage_vbus_voltage_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_clear_errors_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_clear_errors_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_clear_errors_unpack(
    struct odrive_cansimple_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int odrive_cansimple_set_linear_count_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_linear_count_t *src_p,
    size_t size)
{
    uint32_t position;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    position = (uint32_t)src_p->position;
    dst_p[0] |= pack_left_shift_u32(position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_linear_count_unpack(
    struct odrive_cansimple_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position;

    if (size < 8u) {
        return (-EINVAL);
    }

    position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->position = (int32_t)position;

    return (0);
}

int32_t odrive_cansimple_set_linear_count_position_encode(double value)
{
    return (int32_t)(value);
}

double odrive_cansimple_set_linear_count_position_decode(int32_t value)
{
    return ((double)value);
}

bool odrive_cansimple_set_linear_count_position_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_pos_gain_t *src_p,
    size_t size)
{
    uint32_t pos_gain;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&pos_gain, &src_p->pos_gain, sizeof(pos_gain));
    dst_p[0] |= pack_left_shift_u32(pos_gain, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_gain, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_gain, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pos_gain, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_pos_gain_unpack(
    struct odrive_cansimple_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_gain;

    if (size < 8u) {
        return (-EINVAL);
    }

    pos_gain = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pos_gain |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pos_gain |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pos_gain |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pos_gain, &pos_gain, sizeof(dst_p->pos_gain));

    return (0);
}

float odrive_cansimple_set_pos_gain_pos_gain_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_pos_gain_pos_gain_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_pos_gain_pos_gain_is_in_range(float value)
{
    (void)value;

    return (true);
}

int odrive_cansimple_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_vel_gains_t *src_p,
    size_t size)
{
    uint32_t vel_gain;
    uint32_t vel_integrator_gain;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&vel_gain, &src_p->vel_gain, sizeof(vel_gain));
    dst_p[0] |= pack_left_shift_u32(vel_gain, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vel_gain, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vel_gain, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vel_gain, 24u, 0xffu);
    memcpy(&vel_integrator_gain, &src_p->vel_integrator_gain, sizeof(vel_integrator_gain));
    dst_p[4] |= pack_left_shift_u32(vel_integrator_gain, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vel_integrator_gain, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vel_integrator_gain, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vel_integrator_gain, 24u, 0xffu);

    return (8);
}

int odrive_cansimple_set_vel_gains_unpack(
    struct odrive_cansimple_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vel_gain;
    uint32_t vel_integrator_gain;

    if (size < 8u) {
        return (-EINVAL);
    }

    vel_gain = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vel_gain |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vel_gain |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vel_gain |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vel_gain, &vel_gain, sizeof(dst_p->vel_gain));
    vel_integrator_gain = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vel_integrator_gain |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vel_integrator_gain |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vel_integrator_gain |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vel_integrator_gain, &vel_integrator_gain, sizeof(dst_p->vel_integrator_gain));

    return (0);
}

float odrive_cansimple_set_vel_gains_vel_gain_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_vel_gains_vel_gain_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_vel_gains_vel_gain_is_in_range(float value)
{
    (void)value;

    return (true);
}

float odrive_cansimple_set_vel_gains_vel_integrator_gain_encode(double value)
{
    return (float)(value);
}

double odrive_cansimple_set_vel_gains_vel_integrator_gain_decode(float value)
{
    return ((double)value);
}

bool odrive_cansimple_set_vel_gains_vel_integrator_gain_is_in_range(float value)
{
    (void)value;

    return (true);
}
